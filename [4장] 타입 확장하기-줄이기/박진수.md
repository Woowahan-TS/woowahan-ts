# [4장] 타입 확장하기-줄이기
## 4.1 타입 확장하기
### 타입 확장의 장점
- 타입을 확장하게 되면 불필요한 코드를 줄일 수 있다.
```tsx
interface BaseMenuItem {
  itemName: string | null;
  itemImageUrl: string | null;
  itemDiscountAmount: number;
  stock: number | null;
}

interface BaseCartItem extends BaseMenuItem {
  quantity: number;
}
```
- 뿐만 아니라 BaseCartItem이 BaseMenuItem에서 확장되었다는 것을 쉽게 확인할 수 있을만큼 명시적인 코드 작성이 가능하다.
- interface 대신 type을 쓰는 경우
```tsx
type BaseMenuItem = {
  itemName: string | null;
  itemImageUrl: string | null;
  itemDiscountAmount: number;
  stock: number | null;
}

type BaseCartItem = {
  quantity: number;
} & BaseMenuItem;
```

### 유니온 타입
- 유니온 타입은 2개 이상의 타입을 조합하여 사용하는 방법이다.
```tsx
interface CookingStep {
  orderId: string;
  price: number;
}

interface DeliveryStep {
  orderId: string;
  time: number;
  distance: string;
}

function getDeliveryDistance(step: CookingStep | DeliveryStep) {
  return step.distance;
  // 오류: Property 'distance' does not exist on type 'CookingStep | DeliveryStep'
  // 오류: Property 'distance' does no exis on type 'CookingStep'
}
```
- step이라는 유니온 타입은 CookingStep 또는 DeliveryStep 타입에 해당하는 것 뿐이지 CookingStep이면서 DeliveryStep인 것은 아니다.
- 즉, A이거나 B.

### 교차 타입
```tsx
interface CookingStep {
  orderId: string;
  time: number;
  price: number;
}

interface DeliveryStep {
  orderId: string;
  time: number;
  distance: string;
}

type BaedalProgress = CookingStep & DeliveryStep;
```
- 유니온 타입과는 다르게 BaedalProgress 타입은 CookingStep과 DeliveryStep 타입을 합쳐 모든 속성을 가진 단일 타입이 된다.
```tsx
function logBaedalInfo (progress: BaedalProgress) {
  console.log(`주문 금액: ${progress.price}`);
  console.log(`배달 거리: ${progress.distance}`);
}
```
- 따라서 progress 값은 price 속성과 distance 속성 모두 포함하고 있다.
- 다른 예시를 살펴보자
```tsx
interface DeliveryTip {
  tip: string;
}

interface StarRating {
  rate: number;
}

type Filter = DeliveryTip & StarRating;

const filter: Filter = {
  tip: "1000원 이하",
  rate: 4,
};
```
- Filter 타입은 DeliveryTip이랑 StarRating의 속성을 모두 가지고 있는 타입이므로 유니온과는 다르게 성립하는 모습
- 그런데 교차 타입을 사용할 때 타입이 서로 호환되지 않는 경우도 있다.
```tsx
type IdType = string | number;
type Numberic = number | boolean;

type Universal = IdType & Numeric;
```
- Universal 타입은 4가지로 생각할 수 있다.
  - string이면서 number
  - string이면서 boolean
  - number이면서 number
  - number이면서 boolean
 - Universal은 IdType과 Numeric 타입을 모두 만족해야 하므로 number 타입을 갖게 된다.

### extends와 교차 타입
