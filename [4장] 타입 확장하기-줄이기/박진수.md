# [4장] 타입 확장하기-줄이기
## 4.1 타입 확장하기
### 타입 확장의 장점
- 타입을 확장하게 되면 불필요한 코드를 줄일 수 있다.
```tsx
interface BaseMenuItem {
  itemName: string | null;
  itemImageUrl: string | null;
  itemDiscountAmount: number;
  stock: number | null;
}

interface BaseCartItem extends BaseMenuItem {
  quantity: number;
}
```
- 뿐만 아니라 BaseCartItem이 BaseMenuItem에서 확장되었다는 것을 쉽게 확인할 수 있을만큼 명시적인 코드 작성이 가능하다.
- interface 대신 type을 쓰는 경우
```tsx
type BaseMenuItem = {
  itemName: string | null;
  itemImageUrl: string | null;
  itemDiscountAmount: number;
  stock: number | null;
}

type BaseCartItem = {
  quantity: number;
} & BaseMenuItem;
```

### 유니온 타입
- 유니온 타입은 2개 이상의 타입을 조합하여 사용하는 방법이다.
```tsx
interface CookingStep {
  orderId: string;
  price: number;
}

interface DeliveryStep {
  orderId: string;
  time: number;
  distance: string;
}

function getDeliveryDistance(step: CookingStep | DeliveryStep) {
  return step.distance;
  // 오류: Property 'distance' does not exist on type 'CookingStep | DeliveryStep'
  // 오류: Property 'distance' does no exis on type 'CookingStep'
}
```
- step이라는 유니온 타입은 CookingStep 또는 DeliveryStep 타입에 해당하는 것 뿐이지 CookingStep이면서 DeliveryStep인 것은 아니다.
- 즉, A이거나 B.

### 교차 타입
```tsx
interface CookingStep {
  orderId: string;
  time: number;
  price: number;
}

interface DeliveryStep {
  orderId: string;
  time: number;
  distance: string;
}

type BaedalProgress = CookingStep & DeliveryStep;
```
- 유니온 타입과는 다르게 BaedalProgress 타입은 CookingStep과 DeliveryStep 타입을 합쳐 모든 속성을 가진 단일 타입이 된다.
```tsx
function logBaedalInfo (progress: BaedalProgress) {
  console.log(`주문 금액: ${progress.price}`);
  console.log(`배달 거리: ${progress.distance}`);
}
```
- 따라서 progress 값은 price 속성과 distance 속성 모두 포함하고 있다.
- 다른 예시를 살펴보자
```tsx
interface DeliveryTip {
  tip: string;
}

interface StarRating {
  rate: number;
}

type Filter = DeliveryTip & StarRating;

const filter: Filter = {
  tip: "1000원 이하",
  rate: 4,
};
```
- Filter 타입은 DeliveryTip이랑 StarRating의 속성을 모두 가지고 있는 타입이므로 유니온과는 다르게 성립하는 모습
- 그런데 교차 타입을 사용할 때 타입이 서로 호환되지 않는 경우도 있다.
```tsx
type IdType = string | number;
type Numberic = number | boolean;

type Universal = IdType & Numeric;
```
- Universal 타입은 4가지로 생각할 수 있다.
  - string이면서 number
  - string이면서 boolean
  - number이면서 number
  - number이면서 boolean
 - Universal은 IdType과 Numeric 타입을 모두 만족해야 하므로 number 타입을 갖게 된다.

### extends와 교차 타입
- extends를 사용하려면 interface로 타입을 선언하고, 교차 타입과 유니온 타입을 사용하려면 type으로 타입을 선언해야 한다.
- 왜냐하면 유니온 타입과 교차 타입을 사용한 새로운 타입은 오직 type으로만 선언할 수 있기 때문이다.
- 문제는 extends 키워드를 사용한 타입이 교차 타입과 100% 동일하지 않은 문제도 있다.
```tsx
interface DeliveryTip {
  tip: number;
}

interface Filter extends DeliveryTip {
  tip: string;
  // Interface 'Filter' incorrectly extends interface 'DeliveryTip'
  // Types of property 'tip' are incompatible
  // Type 'string' is not assignable to type 'number'
}
```
- DeliveryTip 타입은 number 타입의 tip 속성을 가지고 있다.
- 이때 DeliveryTip을 extends로 확장한 Filter 타입에 string 타입의 속성 tip을 선언하면 tip의 타입이 호환되지 않는다는 에러가 발생한다.
```tsx
type DeliveryTip = {
  tip: number;
}

type Filter = DeliveryTip & {
  tip: string;
}
```
- extends를 &로 바꿨을 뿐인데 에러가 발생하지 않는다. 이때 tip 속성의 타입은 number일까? string일까?
- 정답은 never다.
- type 키워드는 교차 타입으로 선언되었을 때 새롭게 추가되는 속성에 대해 미리 알 수 없기 때문에 선언 시 에러가 발생하지 않는다. (extends는 어차피 미리 선언된 interface와 연결되기 때문에 문제가 안됨)
- 하지만 tip이라는 같은 속성에 대해 서로 호환되지 않는 타입이 선언되어 결국 never 타입이 된 것이다.

<br/>

## 4.2 타입 좁히기 - 타입 가드
- 타입 좁히기는 변수 또는 표현식의 타입 범위를 더 작은 범위로 좁혀나가는 과정을 말한다.
- 타입 좁히기를 통해 더 정확하고 명시적인 타입 추론을 할 수 있게 되고, 복잡한 타입을 작은 범위로 축소하여 타입 안전성을 높일 수 있다.
### 타입 가드에 따라 분기 처리하기
- 여러 타입을 할당하고 조건에 따라 타입을 검사하고 싶은 경우에 타입 가드를 쓸 수 있다.
- 물론, 단순 if문으로 처리한다면 컴파일 시 타입 정보가 모두 제거되기 때문에 안된다.
- 자바스크립트 연산자 typeof, instanceof, in과 같은 것들을 사용하는 방식이 타입 가드 방식이다.
- 즉, 런타임에 유효한 타입 가드를 만드는 방식이다.
```tsx
function doSomething(x: number | string) {
    if (typeof x === "string") {
        console.log(x.substr(0, 1)); // 문자열 메서드 사용
    } else {
        console.log(x + 1); // 숫자 연산 수행
    }
}

// 컴파일 이후

function doSomething(x) {
    if (typeof x === "string") {
        console.log(x.substr(0, 1)); // 문자열 메서드 사용
    } else {
        console.log(x + 1); // 숫자 연산 수행
    }
}
```
### 원시 타입을 추론할 때: typeof 연산자 활용하기
