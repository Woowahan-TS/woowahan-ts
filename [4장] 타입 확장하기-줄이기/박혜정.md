# 4장 타입 확장하기,좁히기

### 목차

1. 타입 확장

## 1. 타입 확장
- 기존의 타입을 사용해 새로운 타입을 정의하는 것.
- 코드 중복을 줄이고 재사용성의 증가
- 확장된 타입에 이름을 부여하여 명시성 증가

### 유니온 타입 : (A | B)
```ts
type A = {
    name: string;
    age: number;
}
type B ={
    name: string;
    age: number;
    hp:number
}

type C = A | B;

function test(arg: C){
    return arg.hp; // 'C' 형식에 'hp' 속성이 없습니다. 'A' 형식에 'hp' 속성이 없습니다.
}
```
- 그냥 arg 의 타입이 A 이거나 B 인거지, arg 가 A와 B의 모든 속성을 다 가지고 있다고 보는 것은 아님.
- 타입이 합쳐지는게 아니라는 의미.

### 교차 타입 : (A & B)
- 두 개 이상의 타입을 결합해 모든 타입의 요구사항을 동시에 만족할 수 있는 타입을 만들어내는 타입!
- 위 예시에서 객체의 두 타입이 있을 때, A와 B의 모든 요구사항을 만족할 수 있는 타입으로 재탄생 시키면...
- 아래와 같이 A 와 B 의 모든 속성 타입이 포함된 타입이 만들어지게 됨
```ts
type A = {
    name: string;
    age: number;
} 
type B ={
    name: string;
    age: number;
    hp:number
}

type C = A & B;

function test(arg: C){
    return arg.hp; // 접근 가능
}
```
- 호환이 되지 않는 케이스는 아래와 같다.
```ts
type A = string | number;
type B = number | boolean;

type C = A & B // number
```
- 위 경우 타입 C 가 A 와 B 를 모두 만족시키는 타입이 되기 위해선, 두 타입이 공통으로 가질 수 있는 타입의 값인 number를 고르게 됌
- 따라서 C 는 number

> ***결론적으로 & 교차 타입은, 교차타입으로 선언된 타입이, 교차 하고자 하는 다른 타입들을 모두 만족시킬 수 있는가를 생각하면 됌***
```ts
type A = string;
type B = number | boolean;

type C = A & B // never
```
- 이렇게 하나도 만족시킬 수 없는 경우 공집합 `never` 타입이 된다.
### extends 와 교차타입
- extends 키워드는 interface 의 확장 개념
- 이걸 & 연산자를 사용한 교차 타입으로 선언하려면 `type` 키워드를 쓰면 된다. 
    - (왜냐면 interface 에서는 `&` 연산자 사용이 허용되지 않기 때문. `|` 연산자도 마찬가지임.)
    - (그 이유는 `interface` 가 객체, 구조체의 타입을 정의하는데 특화된 키워드라서.)
    - (이 타입이 어떤 범위를 가진 값이 될거다- 라는건 `type` 키워드를 사용하는 것이 옳고 계산된 값의 허용도 같은 맥락이라고 생각됨.)
```ts
interface A {
    name : string;
}

interface B extends A {
    name : number;
} 
// 'B' 인터페이스가 'A' 인터페이스를 잘못 확장합니다.
// 'name' 속성의 형식이 호환되지 않습니다.
// 'number' 형식은 'string' 형식에 할당할 수 없습니다.
```
- 위 예시에서 interface 는 호환되지 않는 타입의 재정의를 아예 막아버림
```ts
type A = {
    name : string;
}

type B = A & {
    name: number;
}

const b:B = {
    name: 3
} // 'number' 형식은 'never' 형식에 할당할 수 없습니다.
```
- 위 예시에선 타입 선언시 에러가 발생하진 않지만, 타입을 사용해 값을 할당시 에러가 발생함
- 타입스크립트에선 이런 식의 타입 재정의를 금지하여 타입간의 호환성, 안정성을 유지하고자 함.
- 배민 예시에서는 옵셔널로 추가될 수 있는 속성 타입에 대해 extends 를 통해 확장하여 조금 더 명시적으로 타입을 활용.