# 4장 타입 확장하기,좁히기

### 목차

1. 타입 확장
2. 타입 좁히기 (타입가드)
3. 타입 좁히기 (식별 가능한 유니온)

## 1. 타입 확장

- 기존의 타입을 사용해 새로운 타입을 정의하는 것.
- 코드 중복을 줄이고 재사용성의 증가
- 확장된 타입에 이름을 부여하여 명시성 증가

### 유니온 타입 : (A | B)

```ts
type A = {
  name: string;
  age: number;
};
type B = {
  name: string;
  age: number;
  hp: number;
};

type C = A | B;

function test(arg: C) {
  return arg.hp; // 'C' 형식에 'hp' 속성이 없습니다. 'A' 형식에 'hp' 속성이 없습니다.
}
```

- 그냥 arg 의 타입이 A 이거나 B 인거지, arg 가 A와 B의 모든 속성을 다 가지고 있다고 보는 것은 아님.
- 타입이 합쳐지는게 아니라는 의미.

### 교차 타입 : (A & B)

- 두 개 이상의 타입을 결합해 모든 타입의 요구사항을 동시에 만족할 수 있는 타입을 만들어내는 타입!
- 위 예시에서 객체의 두 타입이 있을 때, A와 B의 모든 요구사항을 만족할 수 있는 타입으로 재탄생 시키면...
- 아래와 같이 A 와 B 의 모든 속성 타입이 포함된 타입이 만들어지게 됨

```ts
type A = {
  name: string;
  age: number;
};
type B = {
  name: string;
  age: number;
  hp: number;
};

type C = A & B;

function test(arg: C) {
  return arg.hp; // 접근 가능
}
```

- 호환이 되지 않는 케이스는 아래와 같다.

```ts
type A = string | number;
type B = number | boolean;

type C = A & B; // number
```

- 위 경우 타입 C 가 A 와 B 를 모두 만족시키는 타입이 되기 위해선, 두 타입이 공통으로 가질 수 있는 타입의 값인 number를 고르게 됌
- 따라서 C 는 number

> **_결론적으로 & 교차 타입은, 교차타입으로 선언된 타입이, 교차 하고자 하는 다른 타입들을 모두 만족시킬 수 있는가를 생각하면 됌_**

```ts
type A = string;
type B = number | boolean;

type C = A & B; // never
```

- 이렇게 하나도 만족시킬 수 없는 경우 공집합 `never` 타입이 된다.

### extends 와 교차타입

- extends 키워드는 interface 의 확장 개념
- 이걸 & 연산자를 사용한 교차 타입으로 선언하려면 `type` 키워드를 쓰면 된다.
  - (왜냐면 interface 에서는 `&` 연산자 사용이 허용되지 않기 때문. `|` 연산자도 마찬가지임.)
  - (그 이유는 `interface` 가 객체, 구조체의 타입을 정의하는데 특화된 키워드라서.)
  - (이 타입이 어떤 범위를 가진 값이 될거다- 라는건 `type` 키워드를 사용하는 것이 옳고 계산된 값의 허용도 같은 맥락이라고 생각됨.)

```ts
interface A {
  name: string;
}

interface B extends A {
  name: number;
}
// 'B' 인터페이스가 'A' 인터페이스를 잘못 확장합니다.
// 'name' 속성의 형식이 호환되지 않습니다.
// 'number' 형식은 'string' 형식에 할당할 수 없습니다.
```

- 위 예시에서 interface 는 호환되지 않는 타입의 재정의를 아예 막아버림

```ts
type A = {
  name: string;
};

type B = A & {
  name: number;
};

const b: B = {
  name: 3,
}; // 'number' 형식은 'never' 형식에 할당할 수 없습니다.
```

- 위 예시에선 타입 선언시 에러가 발생하진 않지만, 타입을 사용해 값을 할당시 에러가 발생함
- 타입스크립트에선 이런 식의 타입 재정의를 금지하여 타입간의 호환성, 안정성을 유지하고자 함.
- 배민 예시에서는 옵셔널로 추가될 수 있는 속성 타입에 대해 extends 를 통해 확장하여 조금 더 명시적으로 타입을 활용.

## 2. 타입 좁히기

- 넓은 범위의 타입을 작은 범위로 좁혀서 더 명시적으로 추론이 가능하도록 하는 방식
- if 문을 사용해서, 어떤 변수가 어떠한 타입일 때 이 타입을 기준으로 분기처리 시키는 것.
- 타입은 컴파일 단계에서 사라지므로, 자바스크립트 연산자인 `typeof` , `instance of` 를 활용
- `typeof` 의 경우 원시 타입의 추론 가능. 복잡한 타입인 경우 object 로 판별되는 등의 이슈가 있음.
- `instance of` 는 조금 더 복잡한 타입의 경우.
  - 역시 타입스크립트 interface 등을 직접 참조하는 것은 안되고, 클래스나 객체의 인스턴스인지를 판별
- 객체 안에 속성이 있는지 없는지! `in` 연산자를 활용.
  - 속성의 존재 여부를 보는 것이기 때문에 그 속성의 값은 상관이 없음.
- `is`로 사용자 정의 타입 가드
  - `A is B` -> 매개변수 A 는 타입 B 이다.
  - 그 명제에 대한 답을 boolean 으로 반환

```ts
function isString(value: any): value is string {
  return typeof value === 'string';
}
```

- 이런 함수가 있다면, 이 함수의 반환 타입은 `value` 라는 매개변수가 string인지 여부를 판단한 값 이라고 보면 됌.
- 타입스크립트가 조금 더 정확하게 데이터 타입을 추론할 수 있게 돕는 도구
- 만약 is 뒤에 다른 커스텀 타입을 넣는다면 더 쉽게 타입 추론이 가능해지겠지

## 3. 타입 좁히기 (식별 가능한 유니온)

```ts
type ErrorFeedback = A | B | C;
const errorArr: ErrorFeedback[] = [
  {code: '1', message: 'a', type: 'A'},
  {code: '2', message: 'b', duration: 100, type: 'B'},
  {code: '3', message: 'c', onConfirm: () => {}, type: 'C'},
  {code: '3', message: 'c', onConfirm: () => {}, type: 'D'}, // error
];
```

- 각각의 타입 A, B, C 에 특정한 유닛 타입을 설정해두면, 그 이외의 값이 왔을 때 정확하게 식별이 가능하다는 것.
- 유닛 타입이라는 것은 쉽게 설명하면 문자열 리터럴 같은 고정 값을 말하는 것.

## 4. Exhaustiveness checking..

- 모든 케이스에 대해 철저하게 체크하라는 것.
- if ... else 구문을 사용해 타입 체킹에 해당되지 않아 걸러지는 나머지 타입이 생기면 바로 에러를 떨구는 방식으로 개발자가 타입을 엄격하게 검사할 수 있도록 강제.
- 어설션?
  - 개발 중 특정 가정이 반드시 참이라는 것을 보장하기 위해서 사용...
  - 예외처리와 다른 점은, 예외 처리란 어떠한 상황이라면... 하고 가정하면서 그에 맞는 처리를 하는거지만,
  - 어설션은 이 값은 절대 거짓이 될 수 없어! 라고 가정하고 사용한다는 차이..?
  - 만약 이 어설션에 위배가 되면 프로그램 실행이 멈추고 에러가 난다던지 .. 이런 방식의 처리가 가능함.
  - 테스트/디버깅 상황에서 유용하다는 것은 어떤 문제가 있는지 빠르게 판단할 수 있다는 점이고, 프로덕션 환경에서 유의가 필요하다는 것은 이렇게 예측하지 못하는 것에 대해 동작이 멈춰버리면 큰일이 나버리기 때문임.
