# 7장 비동기 호출

### 목차

1. 비동기 호출을 관리하는게 왜 중요할까
2. API 요청 잘 관리하기
3. API 상태 관리하기
4. API 에러 핸들링
5. API 모킹

## 1. 비동기 호출을 관리하는게 왜 중요할까
- 프론트엔드에서 보여주고 상호작용 할 수 있는 데이터는 데이터베이스, 서버 백엔드와의 통신을 통해 관리됨
- 이것들에 접근(요청, 응답) 은 비동기로 이루어짐
- 웹 화면이 유의미한 동작을 수행하려면 이런 비동기를 호출해야하고, 비동기를 잘 관리하는 것이 중요함

## 2. API 요청 잘 관리하기
- **서비스 레이어 활용하기**
	- 컴포넌트 내부에서 API 를 호출하기 보다는, 이 비즈니스 로직을 별도로 분리하여 처리할 수 있게 하자.
	- 그렇게 해야 추후에 해당 API 요청에 대한 요구사항이 추가되었을 때 대처하기 쉽다.
- **Axios/Axios Interceptor 활용하기**
	- Axios 는 BaseURL을 기반으로 엔드포인트를 넣어주면 거기에 해당하는 요청을 보내기 쉽도록 해줌
	- 또한 interceptor 기능을 활용해 요청, 응답을 가로채어 특정한 로직을 수행하도록 만들기 좋음.
	- 내가 많이 활용했던 예시로는 요청 중간에 토큰 갱신해주기, 에러 상태에 따라서 로그아웃 처리해주기 등등..
```ts
apiWrapper.interceptors.response.use(
  (res) => res,
  async (err: any) => {
    const { config, response: { status, data } } = err;

    const ERROR_STATUS = {
      EXPIRED: 410,
      INVALID: 401,
      NOT_FOUND: 404,
    };

    const ERROR_MSG = {
      NOT_FOUND: 'User not found',
    };

    if (status === ERROR_STATUS.EXPIRED) {
      if (!refreshTokenPromise) {
        refreshTokenPromise = getRefreshToken().then((newToken) => {
          refreshTokenPromise = null;
          return newToken;
        });
      }

      const updatedConfig = await handleExpiredToken(config);
      return apiWrapper(updatedConfig);
    }

    const isTokenInvalid =
      status === ERROR_STATUS.INVALID ||
      (data.message === ERROR_MSG.NOT_FOUND && accessToken.get());

    if (isTokenInvalid) {
      tokenLogout();
      window.location.assign(LOGIN_SUFFIX);
    }

    return Promise.reject(err);
  }
);

```
- 추가적으로 api 에러가 발생했을 때 API를 호출한 컴포넌트에 도달하기 전에 뭔가 처리를 해준다던지 그런 기능이 가능함.
- APIBuider 를 활용해보자 (빌더 패턴)
	- 어떤 인스턴스를 구성하기 위한 여러 옵션을 클래스의 메서드로 만들고, 이 메서드들을 조합한 뒤 최종적으로 빌드하도록 만들어 인스턴스를 구성하는 기법
	- 기대되는 결과 코드는 아래와 같다.
```ts
const api = APIBuilder
	.get('/apis/web/jobs')
	.withCredentials(true)
	.paramse({ name: size })
	.build();
```
- 보일러 플레이트가 많지만, 옵션이 다양한데 재사용이 많지 않은 경우, 필요한 인터셉터를 선택적으로 사용할 수 있어서 활용도가 좋다.

- **API 응답 타입 지정하기**
	- 서버에서 정의해준 응답 형태를 Response 와 같은 응답 타입으로 지정하고, api 의 응답값에 타입스크립트를 적용시킬 수 있음
	- 하지만 API 에 따라 update, create 같이 응답값이 존재하지 않는 API 가 있을 수 있으므로, 예시에서는 제네릭을 활용해 전달하게 하여 apiRequester 함수가 이 타입을 알지 못하도록 해주었다. 
- **뷰 모델 사용하기**
	- API 변경에 따른 범위 한정
	- 어떤 API 에 대한 응답값을 컴포넌트에서 렌더링 할 때, 이 API 의 응답값이 바뀌어도 UI가 깨지지 않도록 UI <-> View Model <-> API 이러한 구조를 만들어 DIP (Dipendency Inversion Principle) 를 구현하는 것
	- 이 ViewModel 에는 API의 응답값을 UI에 맞는 값으로 변환하는 내용이 포함될 것이다. 그래서 UI가 여기 뷰 모델 하나만을 바라보고 변화에 대응할 수 있도록...
	- 그런데 이런 뷰 모델과 같은 추상클래스가 많아지면 코드 복잡도가 증가하기 때문에 꼭 필요한 부분에 적절하게 사용하는 것이 좋다.
- **Superstruct 사용해 응답 타입 검증하기**
	- 런타임에 타입을 검사할 수 있도록 도와주는 도구
	- API 응답의 경우 TS 에서 아무리 이런 타입일거에요!! 라고 해봤자 API 가 다르게 오면 그냥 터져버리고 끝남
	- zod 랑 비슷한 도구인 것 같은데.. 어떤 차이점이 있는지 살펴볼까?
		- zod 가 좀 무겁고, superstruct 가 굉장히 가볍다 (74% 정도)