# [7장] 비동기 호출
## 7.1 API 요청
### fetch로 API 요청하기
- 백엔드에서 API URL을 수정해야 한다고 했을 때 컴포넌트 내부에 깊숙이 자리 잡은 비동기 호출 코드는 이러한 변경 요구에 취약하다.
- 새로운 API 요청 정책이 추가될 때마다 계속해서 비동기 호출 코드를 수정해야 하는 번거로움을 어떻게 해결할까?

### 서비스 레이어로 분리하기
- 단순히 fetch 함수를 분리하는 것만으로는 API 요청 정책이 추가되는 것을 해결하기 어렵다.

### Axios 활용하기
- 각 서버가 담당하는 부분이 다르거나 새로운 프로젝트의 일부로 포함될 때 기존에 사용하던 API Entry(Base URL)와는 다른 새로운 URL로 요청해야 하는 상황이 생길 수 있다.
- 이럴 땐 2개 이상의 API 요청을 처리하는 인스턴스를 따로 구성하면 된다. (어찌보면 당연한 말)
```tsx
const apiRequester: AxiosInstance = axios.create(defaultConfig);
const orderApiRequester: AxiosInstance = axios.create({
  baseURL: "https://api.baemin.or/",
  ...defaultConfig,
});

const orderCartApiRequester: AxiosInstance = axios.create({
  baseURL: "https://cart.baemin.order/",
  ...defaultConfig,
});
```

### Axios 인터셉터 사용하기
- axiosInterceptor를 사용하게 된다면 백엔드 서버 응답에 따라 추가적으로 작동하는 로직을 구현할 수 있다.
- 그런데 요청 옵션에 따라 다른 인터셉터를 만들기 위해 빌더 패턴을 추가하여 APIBuilder 같은 클래스 형태로 구성하기도 한다.
```md
🧐 짚고 넘어가기

빌더 패턴
- 객체 생성을 더 편리하고 가독성 있게 만들기 위한 디자인 패턴 중 하나다. 주로 복잡한 객체의 생성을 단순화하고, 객체 생성 과정을 분리하여 객체를 조립하는 방법을 제공한다.
```
```tsx
class API {
  readonly method: HTTPMethod;
  readonly url: string;
  baseURL?: string;
  headers?: HTTPHeaders;
  params?: HTTPParams;
  data?: unknown;
  timeout?: number;
  withCredentials?: boolean;

  constructor(method: HTTPMethod, url: string) {
    this.method = method;
    this.url = url'
  }

  call<T>(): AxiosPromise<T> {
    const http = axios.create();

    // 만약 'withCredentail'이 설정된 API라면 아래 같이 인터셉터를 추가하고, 아니라면 인터셉터를 사용하지 않음 [7장] 비동기 호출
## 7.1 API 요청
### fetch로 API 요청하기
- 백엔드에서 API URL을 수정해야 한다고 했을 때 컴포넌트 내부에 깊숙이 자리 잡은 비동기 호출 코드는 이러한 변경 요구에 취약하다.
- 새로운 API 요청 정책이 추가될 때마다 계속해서 비동기 호출 코드를 수정해야 하는 번거로움을 어떻게 해결할까?

### 서비스 레이어로 분리하기
- 단순히 fetch 함수를 분리하는 것만으로는 API 요청 정책이 추가되는 것을 해결하기 어렵다.

### Axios 활용하기
- 각 서버가 담당하는 부분이 다르거나 새로운 프로젝트의 일부로 포함될 때 기존에 사용하던 API Entry(Base URL)와는 다른 새로운 URL로 요청해야 하는 상황이 생길 수 있다.
- 이럴 땐 2개 이상의 API 요청을 처리하는 인스턴스를 따로 구성하면 된다. (어찌보면 당연한 말)
```tsx
const apiRequester: AxiosInstance = axios.create(defaultConfig);
const orderApiRequester: AxiosInstance = axios.create({
  baseURL: "https://api.baemin.or/",
  ...defaultConfig,
});

const orderCartApiRequester: AxiosInstance = axios.create({
  baseURL: "https://cart.baemin.order/",
  ...defaultConfig,
});
```

### Axios 인터셉터 사용하기
- axiosInterceptor를 사용하게 된다면 백엔드 서버 응답에 따라 추가적으로 작동하는 로직을 구현할 수 있다.
- 그런데 요청 옵션에 따라 다른 인터셉터를 만들기 위해 빌더 패턴을 추가하여 APIBuilder 같은 클래스 형태로 구성하기도 한다.
```md
🧐 짚고 넘어가기

빌더 패턴
- 객체 생성을 더 편리하고 가독성 있게 만들기 위한 디자인 패턴 중 하나다. 주로 복잡한 객체의 생성을 단순화하고, 객체 생성 과정을 분리하여 객체를 조립하는 방법을 제공한다.
```

### API 응답 타입 지정하기
- 같은 서버에서 오는 응답의 형태는 대체로 통일되어 있어서 앞서 소개한 API의 응답 값은 하나의 Response 타입으로 묶일 수 있다.
```tsx
interface Response<T> {
  data: T;
  status: string;
  serverDateTime: string;
  errorCode?: string; // FAIL, ERROR
  errorMessage?: string; // FAIL, ERROR
}

const fetchCart = () : AxiosPromise<Response<FetchCartResponse>> =>
  apiRequester.get<Response<FetchCartResponse>> "cart";

const posetCart = (postCartRequest: PostCartRequest): AxiosPromise<Response<PostCartResponse>> =>
  apiRequester.post<Response<PostCartResponse>>("cart", postCartRequest);
```
- 그런데 이처럼 서버에서 오는 응답을 통일해줄 때 주의할 점이 있다.
- Response 타입을 apiRequester 내에서 처리하고 싶다는 생각이 들 수 있는데, 이렇게 하면 UPDATE나 CREATE 같이 응답이 없을 수 있는 API를 처리하기 까다로워진다.
```tsx
const updateCart = (updateCartRequest): AxiosPromise<Response<FetchCartResponse>>
=>
  apiRequester.get("cart");
```
- 따라서 Response 타입은 apiRequester가 모르게 관리되어야 한다.
- API 요청 및 응답 값 중에서는 하나의 API 서버에서 다른 API 서버로 넘겨주기만 하는 값도 존재할 수 있다.
- 해당 값에 어떤 응답이 들어있는지 알 수 없거나 값의 형식이 달라지더라도 로직에 영향을 주지 않는 경우에는 unknown 타입을 사용하여 알 수 없는 값임을 표현한다.
```tsx
interface response {
  data: {
    cartItems: CartItem[];
    forPass: unknown;
  };
}
```
- 그래도 unknown 타입으로 선언했을 때 사용하려면 분기처리가 진행되어야 하므로 조심해야 한다.

### Superstruct를 사용해 런타임에서 응답 타입 검증하기
- 몰랐었는데, 백엔드 API 응답 타입이 잘못 들어오는 경우 이를 타입스크립트 컴파일 시점에 체크하지 못한다고 한다.
- 즉, 예상치 못한 타입의 값이 백엔드 실수로 들어오게 되었을 때 프론트에서 타입스크립트를 쓰더라도 런타임에서 에러가 발생할 수 있다는 뜻이다.
- 이러한 경우를 방지하기 위해 런타임에서 응답 타입을 검증할 수 있는 라이브러리를 사용하는 것이고, Superstruct를 배민에서 사용하는 것이다.
```md
🧐 짚고 넘어가기

Superstruct?
- Superstruct를 사용하여 인터페이스 정의와 자바스크립트 데이터의 유효성 검사를 쉽게 할 수 있다.
- Superstruct는 런타임에서의 데이터 유효성 검사를 통해 개발자와 사용자에게 자세한 런타임 에러를 보여주기 위해 고안되었다.
```
- Superstruct 공식 문서에서 제공하는 간단한 코드 예시를 확인해보자.
```tsx
import { assert, is, validate, object, number, string, array } from "superstruct";

const Article = object({
  id: number(),
  title: string(),
  tags: array(string()),
  author: object({
    id: number(),
  }),
});

const data = {
  id: 34,
  title: "Hello World",
  tags: ["news", "featuers"],
  author: {
    id: 1,
  },
};

assert(data, Article);
is(data, Article);
validate(data, Article);
```
- 먼저 Article이라는 변수는 Superstruct의 object() 모듈의 반환 결과다.
- object()라는 모듈 이름에서 예상할 수 있듯이 Article은 object(객체) 형태를 가진 무언가라고 생각할 수 있다. 
- article, is, validate는 각각 역할이 있다.
```md
- assert는 유효하지 않을 경우 에러를 던진다.
- is는 유효성 검사 결과에 따라 true 또는 false 즉, boolean 값을 반환한다.
- validate는 [error, data] 형식의 튜플을 반환한다. 유효하지 않을 때는 에러 값이 반환되고 유효한 경우에는 첫 번째 요소로 undefined, 두 번째 요소로 data value가 반환된다.
```
```tsx
import { assert, object, string, number, optional } from 'superstruct'

// 사용자 정의 구조를 생성
const User = object({
  id: number(),
  name: string(),
  email: optional(string()),  // 선택적 필드
  age: optional(number())
});

// 검증할 데이터
const data = {
  id: 1,
  name: 'Jane Doe',
  email: 'jane@example.com'
};

try {
  // 데이터가 구조에 부합하는지 검증
  assert(data, User);
  console.log("유효한 데이터입니다!");
} catch (error) {
  console.error(error);
}
```

### 실제 API 응답 시의 Superstruct 활용 사례
- API 응답 시 활용되는 방법을 예시로 알아보자.
- fetchList의 호출 결과는 ListItem 타입의 배열이다. 여기에서는 ListIten 타입이 다음과 같다고 가정해보자.
```tsx
interface ListItem {
  id: string;
  content: string;
}

interface ListResponse {
  items: ListItem[];
}

const fetchList = async (filter?: ListFetchFilter): Promise<ListResponse> => {
  const { data } = await api
    .params({ ...filter })
    .get("/apis/get-list-summaries")
    .call<Response<ListResponse>>();

  return { data };
};
```
- 백엔드에서 우리가 원하는 ListItem 타입 배열의 응답이 왔으면 좋겠지만 안 올 수도 있다.
- 이때 Superstruct를 활용하여 타입스크립트로 선언한 타입과 실제 런타임에서의 데이터 응답 값을 매칭하여 유효성 검사를 할 수 있다.
```tsx
import { assert } from "superstruct";

function isListItem(listItems: ListItem[]) {
  listItems.forEach((listItem) => assert(listItem, ListItem));
}
```
- 위의 코드를 기존 fetchList와 합치면 아래와 같아진다.
```tsx
import { assert, object, string } from 'superstruct';

interface ListItem {
  id: string;
  content: string;
}

interface ListResponse {
  items: ListItem[];
}

// Superstruct를 사용한 ListItem 구조 정의
const ListItemStruct = object({
  id: string(),
  content: string()
});

// 배열 내 모든 ListItem이 유효한지 확인하는 함수
function isListItem(listItems: ListItem[]) {
  listItems.forEach((listItem) => {
    try {
      assert(listItem, ListItemStruct);
    } catch (error) {
      console.error("유효하지 않은 아이템입니다:", error);
      throw error; // 오류를 상위로 전파
    }
  });
  console.log("모든 아이템이 유효합니다.");
}

const fetchList = async (filter?: ListFetchFilter): Promise<ListResponse> => {
  const { data } = await api
    .params({ ...filter })
    .get("/apis/get-list-summaries")
    .call<Response<ListResponse>>();

  // 받아온 아이템 리스트에 대한 유효성 검사
  isListItem(data.items);

  return data;
};
```

<br/>

## 7.2 API 상태 관리하기
