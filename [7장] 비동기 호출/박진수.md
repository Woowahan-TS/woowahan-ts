# [7장] 비동기 호출
## 7.1 API 요청
### fetch로 API 요청하기
- 백엔드에서 API URL을 수정해야 한다고 했을 때 컴포넌트 내부에 깊숙이 자리 잡은 비동기 호출 코드는 이러한 변경 요구에 취약하다.
- 새로운 API 요청 정책이 추가될 때마다 계속해서 비동기 호출 코드를 수정해야 하는 번거로움을 어떻게 해결할까?

### 서비스 레이어로 분리하기
- 단순히 fetch 함수를 분리하는 것만으로는 API 요청 정책이 추가되는 것을 해결하기 어렵다.

### Axios 활용하기
- 각 서버가 담당하는 부분이 다르거나 새로운 프로젝트의 일부로 포함될 때 기존에 사용하던 API Entry(Base URL)와는 다른 새로운 URL로 요청해야 하는 상황이 생길 수 있다.
- 이럴 땐 2개 이상의 API 요청을 처리하는 인스턴스를 따로 구성하면 된다. (어찌보면 당연한 말)
```tsx
const apiRequester: AxiosInstance = axios.create(defaultConfig);
const orderApiRequester: AxiosInstance = axios.create({
  baseURL: "https://api.baemin.or/",
  ...defaultConfig,
});

const orderCartApiRequester: AxiosInstance = axios.create({
  baseURL: "https://cart.baemin.order/",
  ...defaultConfig,
});
```

### Axios 인터셉터 사용하기
- axiosInterceptor를 사용하게 된다면 백엔드 서버 응답에 따라 추가적으로 작동하는 로직을 구현할 수 있다.
- 그런데 요청 옵션에 따라 다른 인터셉터를 만들기 위해 빌더 패턴을 추가하여 APIBuilder 같은 클래스 형태로 구성하기도 한다.
```md
🧐 짚고 넘어가기

빌더 패턴
- 객체 생성을 더 편리하고 가독성 있게 만들기 위한 디자인 패턴 중 하나다. 주로 복잡한 객체의 생성을 단순화하고, 객체 생성 과정을 분리하여 객체를 조립하는 방법을 제공한다.
```
```tsx
class API {
  readonly method: HTTPMethod;
  readonly url: string;
  baseURL?: string;
  headers?: HTTPHeaders;
  params?: HTTPParams;
  data?: unknown;
  timeout?: number;
  withCredentials?: boolean;

  constructor(method: HTTPMethod, url: string) {
    this.method = method;
    this.url = url'
  }

  call<T>(): AxiosPromise<T> {
    const http = axios.create();

    // 만약 'withCredentail'이 설정된 API라면 아래 같이 인터셉터를 추가하고, 아니라면 인터셉터를 사용하지 않음 [7장] 비동기 호출
## 7.1 API 요청
### fetch로 API 요청하기
- 백엔드에서 API URL을 수정해야 한다고 했을 때 컴포넌트 내부에 깊숙이 자리 잡은 비동기 호출 코드는 이러한 변경 요구에 취약하다.
- 새로운 API 요청 정책이 추가될 때마다 계속해서 비동기 호출 코드를 수정해야 하는 번거로움을 어떻게 해결할까?

### 서비스 레이어로 분리하기
- 단순히 fetch 함수를 분리하는 것만으로는 API 요청 정책이 추가되는 것을 해결하기 어렵다.

### Axios 활용하기
- 각 서버가 담당하는 부분이 다르거나 새로운 프로젝트의 일부로 포함될 때 기존에 사용하던 API Entry(Base URL)와는 다른 새로운 URL로 요청해야 하는 상황이 생길 수 있다.
- 이럴 땐 2개 이상의 API 요청을 처리하는 인스턴스를 따로 구성하면 된다. (어찌보면 당연한 말)
```tsx
const apiRequester: AxiosInstance = axios.create(defaultConfig);
const orderApiRequester: AxiosInstance = axios.create({
  baseURL: "https://api.baemin.or/",
  ...defaultConfig,
});

const orderCartApiRequester: AxiosInstance = axios.create({
  baseURL: "https://cart.baemin.order/",
  ...defaultConfig,
});
```

### Axios 인터셉터 사용하기
- axiosInterceptor를 사용하게 된다면 백엔드 서버 응답에 따라 추가적으로 작동하는 로직을 구현할 수 있다.
- 그런데 요청 옵션에 따라 다른 인터셉터를 만들기 위해 빌더 패턴을 추가하여 APIBuilder 같은 클래스 형태로 구성하기도 한다.
```md
🧐 짚고 넘어가기

빌더 패턴
- 객체 생성을 더 편리하고 가독성 있게 만들기 위한 디자인 패턴 중 하나다. 주로 복잡한 객체의 생성을 단순화하고, 객체 생성 과정을 분리하여 객체를 조립하는 방법을 제공한다.
```

### API 응답 타입 지정하기
- 같은 서버에서 오는 응답의 형태는 대체로 통일되어 있어서 앞서 소개한 API의 응답 값은 하나의 Response 타입으로 묶일 수 있다.
```tsx
interface Response<T> {
  data: T;
  status: string;
  serverDateTime: string;
  errorCode?: string; // FAIL, ERROR
  errorMessage?: string; // FAIL, ERROR
}

const fetchCart = () : AxiosPromise<Response<FetchCartResponse>> =>
  apiRequester.get<Response<FetchCartResponse>> "cart";

const posetCart = (postCartRequest: PostCartRequest): AxiosPromise<Response<PostCartResponse>> =>
  apiRequester.post<Response<PostCartResponse>>("cart", postCartRequest);
```
- 그런데 이처럼 서버에서 오는 응답을 통일해줄 때 주의할 점이 있다.
- Response 타입을 apiRequester 내에서 처리하고 싶다는 생각이 들 수 있는데, 이렇게 하면 UPDATE나 CREATE 같이 응답이 없을 수 있는 API를 처리하기 까다로워진다.
```tsx
const updateCart = (updateCartRequest): AxiosPromise<Response<FetchCartResponse>>
=>
  apiRequester.get("cart");
```
- 따라서 Response 타입은 apiRequester가 모르게 관리되어야 한다.
- API 요청 및 응답 값 중에서는 하나의 API 서버에서 다른 API 서버로 넘겨주기만 하는 값도 존재할 수 있다.
- 해당 값에 어떤 응답이 들어있는지 알 수 없거나 값의 형식이 달라지더라도 로직에 영향을 주지 않는 경우에는 unknown 타입을 사용하여 알 수 없는 값임을 표현한다.
```tsx
interface response {
  data: {
    cartItems: CartItem[];
    forPass: unknown;
  };
}
```
- 그래도 unknown 타입으로 선언했을 때 사용하려면 분기처리가 진행되어야 하므로 조심해야 한다.

### Superstruct를 사용해 런타임에서 응답 타입 검증하기
- 몰랐었는데, 백엔드 API 응답 타입이 잘못 들어오는 경우 이를 타입스크립트 컴파일 시점에 체크하지 못한다고 한다.
- 즉, 예상치 못한 타입의 값이 백엔드 실수로 들어오게 되었을 때 프론트에서 타입스크립트를 쓰더라도 런타임에서 에러가 발생할 수 있다는 뜻이다.
- 이러한 경우를 방지하기 위해 런타임에서 응답 타입을 검증할 수 있는 라이브러리를 사용하는 것이고, Superstruct를 배민에서 사용하는 것이다.
```md
🧐 짚고 넘어가기

Superstruct?
- Superstruct를 사용하여 인터페이스 정의와 자바스크립트 데이터의 유효성 검사를 쉽게 할 수 있다.
- Superstruct는 런타임에서의 데이터 유효성 검사를 통해 개발자와 사용자에게 자세한 런타임 에러를 보여주기 위해 고안되었다.
```
- Superstruct 공식 문서에서 제공하는 간단한 코드 예시를 확인해보자.
```tsx
import { assert, is, validate, object, number, string, array } from "superstruct";

const Article = object({
  id: number(),
  title: string(),
  tags: array(string()),
  author: object({
    id: number(),
  }),
});

const data = {
  id: 34,
  title: "Hello World",
  tags: ["news", "featuers"],
  author: {
    id: 1,
  },
};

assert(data, Article);
is(data, Article);
validate(data, Article);
```
- 먼저 Article이라는 변수는 Superstruct의 object() 모듈의 반환 결과다.
- object()라는 모듈 이름에서 예상할 수 있듯이 Article은 object(객체) 형태를 가진 무언가라고 생각할 수 있다. 
