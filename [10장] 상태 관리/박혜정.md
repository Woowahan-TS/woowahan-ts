# 10장. 상태관리

## 1. 상태란.

- 시간이 지나면서 변할 수 있는 동적인 데이터.
- 특히 리액트에서는, 변함과 동시에 리렌더링을 불러 일으키는 값을 지칭
- 지역상태, 전역상태, 서버상태로 구분.

**지역 상태**

- 컴포넌트 내부에서만 사용되는 상태. useState, useReducer 로 정의된 값을 의미.

**전역 상태**

- 앱 전체에서 공유되는 상태값
- 여러 컴포넌트가 해당 상태에 접근 가능하고, 업데이트시 이를 참조하는 여러 컴포넌트가 함께 업데이트.

**서버 상태**

- 외부 서버에서 저장, 관리되는 상태
- react query, SWR 과 같은 라이브러리를 통해 관리

## 2. 상태를 남발하지 말자.

- 시간에 따라 변할 수 있는 값이기 때문에, 너무 많아지면 앱의 동작을 예측하기 힘들게 만든다.
- 그래서 상태를 꼭 필요한 경우 최소화 하는 것이 좋은데,
- 이 때 기준을 다음과 같이 결정할 수 있다.

**시간이 지나도 변하는가?**

- 변하지 않는 값이라면 상태가 아니다.
- 특정한 경우에 대해서만 변하게 하려면, useMemo 를 사용해 값의 업데이트를 조절할 수 있다.
- 혹은 리렌더링에 영향을 받지 않는 useRef 를 쓰는 것도 방법.

**파생된 값은 상태가 아니다**

- 부모에게서 전달받는 props
- 기존 값에서 계산되어 도출될 수 있는 값.
- Single Source Of Truth, 단일 책임 원칙에 따라 데이터의 출처를 하나로 (부모로 부터 받는 props 로)
- 그렇게 해야만 부모쪽에 있는 데이터와의 동기화가 가능해짐.
- 이런 경우 상태끌어올리기를 통해 setter 혹은 값의 변경이 가능한 핸들러를 값과 함께 전달해 업데이트 하는 패턴이 권장됨

## 3. useReducer 를 사용하는 예시

- 종종 복잡한 상태값 업데이트에 useReducer 를 사용해 코드를 정리하곤 하는데, 아래 예시를 보면 아주 초간단으로 쓸 수 있는 방법도 제공해주고 있다.

```ts
const [fold, setFold] = useReducer(v => !v, true);
```

- 첫번째 인자가 reducer 함수이고, 두 번째 인자가 초기값이기 때문에 이런 토글 reducer 함수에 대해 별도 정의하지 않고 바로 전달해버리는...

## 4. Context API

- Context API 를 잘 사용하지 않는데, 그 이유로는 익히 알려진 문제점, 프로바이더의 props 의 값 혹은 참조가 변할 때 (업데이트가 일어날 때) 해당 컨텍스트를 구독하는 모든 컴포넌트가 리렌더링 되기 때문.
- 하지만 관심사로 묶인 아주 좁은 영역에서 사용한다면 충분히 가치는 있을 것이라는 생각도 든다.

## 5. 상태관리 라이브러리

![이미지](https://i.imgur.com/JaULtkd.png)

- 1년간 npm trends 를 살펴보면 redux 는 여전히 높은 순위를 차지하고 있음
- 그 뒤에 신흥 강자 zustand 가 추격중
- recoil 은 업데이트가 너무 안되어서 많이 사용하지 않는 추세임
- 보일러플레이트가 많아도 처음부터 탄탄한 설계를 바탕으로 상태를 관리한다면 redux 를
- recoil 처럼 보일러플레이트를 적게 가져가며 사용한다면 zustand 를 추천
