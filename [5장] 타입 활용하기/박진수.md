# [5장] 타입 활용하기
## 5.1 조건부 타입
### extends와 제네릭을 활용한 조건부 타입
- 조건부 타입에서 extends를 사용할 때는 자바스크립트 삼항 연산자와 함께 쓴다.
```tsx
interface Bank {
  financialCode: string;
  companyName: string;
  name: string;
  fullName: string;
}

interface Card {
  financialCode: string;
  companyName: string;
  name: string;
  appCardType?: string;
}
type PayMethod<T> = T extends "card" ? Card : Bank;
type CardPayMethodType = PayMethod<"card">;
type BankPayMethodType = PayMethod<"bank">;
```
### 조건부 타입을 사용하지 않았을 떄의 문제점
- 배민 코드가 예시로 나와있는데 다 이해할 필요는 없고 핵심만 정리하자면
```tsx
type PayMethodType = PayMethodInfo<Card> | PayMethodInfo<Bank>;

export const useGetRegisteredList = (
  type: "card" | "appcard" | "bank"
): UseQueryResult<PayMethodType[])> => {
  // 코드 생략...

  const result = useCommonQuery<PayMethodType[]>(url, undefined, fetcher);

  return result;
};
```
- 위의 코드에서 PayMethodType이 유니온 타입으로 묶여있다.
- 그런데 useGetRegisteredList의 리턴 타입은 PayMethodType이다.
- 즉, 유니온 타입으로 묶여있기 때문에 정확히 어떤 타입으로 반환하는지가 정해지지 않는 문제가 발생한다.
### extends 조건부 타입을 활용하여 개선하기
- 이 부분 설명에 약간의 오류가 있는 것 같다.
- 위에서 PayMethodType이 PayMethodInfo<Card> | PayMethodInfo<Bank> 타입인 문제를 extends를 통해 해결하면
```tsx
type PayMethodType<T extends "card" | "appcard" | "bank"> = T extends
  | "card"
  | "appcard"
  ? Card
  : Bank;
```
- 이런식으로 해결할 수 있고, PayMehodType의 제네릭 타입으로 "card", "appcard", "bank" 리터럴 타입이 들어오면 extends를 통해 Card 또는 Bank로 타입을 지정해줄 수 있다.
- 그런데 설명에는 PayMethodInfo<Card> 타입과 PayMethodInfo<Bank> 타입을 반환한다고 되어있는데 이 부분이 오류 같다.
- 즉, 간단히 설명하자면 extends는 제네릭에 대해 컴파일 단계에서 타입가드를 할 수 있는 것이다.
- 본인은 typeof로 막으면 되지 않나 생각했지만, typeof는 런타임 단계에서 막는거고 제네릭은 컴파일 단계에서 타입이 결정되는 부분이라 서로 호환이 안된다고 한다.
- 따라서 제네릭의 타입 가드를 위해서 extends를 사용하는 것이다.

### infer를 활용해서 타입 추론하기
- 배민 코드가 복잡해서 쉬운 예시를 들었다.
```tsx
type InferReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

function example() {
    return { id: 123, name: "John Doe", isActive: true };
}

type ExampleReturnType = InferReturnType<typeof example>;
// ExampleReturnType is { id: number; name: string; isActive: boolean; }
```
- 위 코드 예시를 보았을 떄 알 수 있는 점은, infer는 제네릭으로 들어온 함수 내부의 속성 타입을 추론할 수 있다는 것이다.
- Api 응답 값에 대해서도 추론할 수 있다.
```tsx
interface ApiResponse<Data> {
    data: Data;
    error: string | null;
}

type ExtractApiResponse<T> = T extends ApiResponse<infer K> ? K : never;

// ApiResponse 타입을 명시적으로 apiResponse 객체에 적용
const apiResponse: ApiResponse<{ id: number, name: string }> = {
    data: { id: 1, name: "John Doe" },
    error: null
};

type ApiResponseData = ExtractApiResponse<typeof apiResponse>;
// ApiResponseData는 { id: number, name: string } 타입
```

<br/>

## 5.2 템플릿 리터럴 타입 활용하기
- 해당 챕터는 간단하게 설명하자면, 리터럴로 타입을 지정할 수 있고 리터럴을 합쳐서도 타입을 지정할 수 있다는 것에 대해 설명하고 있다.
```tsx
type Direction =
  | "top"
  | "topLeft"
  | "topRight"
  | "bottom"
  | "bottomLeft"
  | "bottomRight";
//이렇게 선언할 수 있지만 코드가 길어진다.

type Vertical = "top" | "bottom";
type Horizon = "left" | "right";

type Direction = Vertical | `${Vertical}${Capitalize<Horizon>}`;
```
- 주의할 점은 타입스크립트 컴파일러가 유니온을 추론하는 데 시간이 오래 걸리면 그냥 에러를 내뱉는 경우가 있다.
- 따라서 리터럴 타입에삽입된 유니온 조합의 수가 너무 많지 않게 나누는 것이 좋다.

<br/>

## 5.3 커스텀 유틸리티 타입 활용하기
