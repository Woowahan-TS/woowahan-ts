# [5장] 타입 활용하기
## 5.1 조건부 타입
### extends와 제네릭을 활용한 조건부 타입
- 조건부 타입에서 extends를 사용할 때는 자바스크립트 삼항 연산자와 함께 쓴다.
```tsx
interface Bank {
  financialCode: string;
  companyName: string;
  name: string;
  fullName: string;
}

interface Card {
  financialCode: string;
  companyName: string;
  name: string;
  appCardType?: string;
}
type PayMethod<T> = T extends "card" ? Card : Bank;
type CardPayMethodType = PayMethod<"card">;
type BankPayMethodType = PayMethod<"bank">;
```
### 조건부 타입을 사용하지 않았을 떄의 문제점
- 배민 코드가 예시로 나와있는데 다 이해할 필요는 없고 핵심만 정리하자면
```tsx
type PayMethodType = PayMethodInfo<Card> | PayMethodInfo<Bank>;

export const useGetRegisteredList = (
  type: "card" | "appcard" | "bank"
): UseQueryResult<PayMethodType[])> => {
  // 코드 생략...

  const result = useCommonQuery<PayMethodType[]>(url, undefined, fetcher);

  return result;
};
```
- 위의 코드에서 PayMethodType이 유니온 타입으로 묶여있다.
- 그런데 useGetRegisteredList의 리턴 타입은 PayMethodType이다.
- 즉, 유니온 타입으로 묶여있기 때문에 정확히 어떤 타입으로 반환하는지가 정해지지 않는 문제가 발생한다.
### extends 조건부 타입을 활용하여 개선하기
- 이 부분 설명에 약간의 오류가 있는 것 같다.
- 위에서 PayMethodType이 PayMethodInfo<Card> | PayMethodInfo<Bank> 타입인 문제를 extends를 통해 해결하면
```tsx
type PayMethodType<T extends "card" | "appcard" | "bank"> = T extends
  | "card"
  | "appcard"
  ? Card
  : Bank;
```
- 이런식으로 해결할 수 있고, PayMehodType의 제네릭 타입으로 "card", "appcard", "bank" 리터럴 타입이 들어오면 extends를 통해 Card 또는 Bank로 타입을 지정해줄 수 있다.
- 그런데 설명에는 PayMethodInfo<Card> 타입과 PayMethodInfo<Bank> 타입을 반환한다고 되어있는데 이 부분이 오류 같다.
