# 3장 고급 타입

## 3.1 타입스크립트만의 독자적 타입 시스템

### 1. any 타입

any 타입은 자바스크립트의 모든 값을 오류 없이 받을 수 있다.

자바스크립트에서의 기본적인 사용 방식과 같아 타입을 명시하지 않은 것과 같기 때문에 타입스크립트로 달성하고자 하는 정적 타이핑을 무색하게 만들 수 있다.

하지만 어쩔 수 없이 사용해야 하는 경우가 있다.

1. 개발 단계에서 임시로 값을 지정해야 할 때
2. 어떤 값을 받아올지 또는 넘겨줄지 정할 수 없을 때
3. 값을 예측할 수 없을 때 암묵적으로 사용

> any 타입은 개발자에게 편의성과 확장성을 제공하지만 남용하면 타입의 안정성을 보장할 수 없어 해당 값을 파악하는 데 오히려 더 비용이 들 수 있고 온전히 개발자 스스로 책임을 져야 한다.

### 2. unknown 타입

unknown 타입은 any 타입과 유사하지만 any 를 제외한 타른 타입으로 선언된 변수에는 unknown 타입 값을 할당 할 수 없다.

any

- 어떤 타입이든 any 타입에 할당 가능
- any 타입은 어떤 타입으로도 할당 가능(단 never 는 제외)

unknown

- 어떤 타입이든 unknown 타입에 할당 가능
- unknown 타입은 any 타입 외에 다른 타입으로 할당 불가능

unknown 타입은 타입스크립트만의 타입 시스템으로 any 타입으로 일어날 수 있는 상황들을 보완하기 위해 등장한 타입이다.

any 타입과 유사하지만 타입 검사를 강제하고 타입이 식별된 후에 사용할 수 있기 때문에 any 타입보다 더 안전하다. 따라서 데이터 구조를 파악하기 힘들 때 any 타입 대신 unknown 타입으로 대체해서 사용하는 방법이 권장된다.

### 3. void 타입

함수의 타입을 지정해 줄 때 아무런 값을 반환하지 않는 경우에 사용한다.

자바스크립트에서는 함수에서 명시적인 반환문을 작성하지 않으면 기본적으로 undefined 가 반환된다. 하지만 타입스크립트에서는 void 타입이 사용되는데 이것은 undefined 가 아니다.

변수에도 void 타입을 사용할 수 있지만 함수가 아닌 값에 대해서는 대부분 무의미하다.<br/>
void 타입으로 지정된 변수는 undefined 또는 null 값만 할당 할 수 있다.

### 4. never 타입

함수와 관련해서 많이 사용되는 타입이다.

값을 반환할 수 없는 타입을 말한다. 값을 반환할 수 없는 예는 2가지로 나눌 수 있다.

1. 에러를 던지는 경우
   - 에러가 발생하는 경우는 값을 반환하는 것으로 간주하지 않는다.
2. 무한히 함수가 실행되는 경우

never 타입은 모든 타입의 하뉘 타입이다. 즉, never 는 자신을 제외한 다른 타입을 할당할 수 없다. any도 할당될 수 없다.

### 5. Array 타입

타입스크립트에서 Array 를 언급하는 이유

- 자바스크립트에서는 배열을 객체에 속하는 타입으로 분류한다. 자바스크립트에서는 배열을 단독으로 배열이라는 자료형에 국한하지 않는다.
- 타입스크립트에서 Array 라는 타입을 사용하기 위해서는 타입스크립트의 특수한 문법을 함께 다뤄야 한다.

자바스크립트에서 배열은 동적 언어의 특징에 따라 어떤 값이든 배열의 원소로 허용한다.

하지만 이런 개념은 타입스크립트의 정적 타이핑과 잘 부합하지 않는다. <br />
다른 정적 타입 언어에서는 배열을 선언할 때 크기까지 제한하지만 타입스크립트는 크기까지 제한하지는 않지만 타입의 원소를 관리하는 것을 강제한다.

배열 타입을 선언하는 두 가지 방식

- 대괄호([]) 형식

```ts
const array: number[] = [1, 2, 3]; // 숫자에 해당하는 원소만 허용한다.
```

- 제네릭 형식

```ts
const array: Array<number> = [1, 2, 3]; // number[] 와 동일한 타입이다.
```

타입스크립트에서 배열 타입을 명시하는 것만으로 배열의 길이까지는 제한할 수 없다. 그러나 튜플은 배열의 하위 타입으로 기존 타입스크립트의 배열 기능에 길이 제한까지 추가한 타입 시스템으로 볼 수 있다.

```ts
let tuple: [number] = [1];

tuple = [1, 2]; // 불가능
tuple = [1, "string"]; // 불가능

let tuple: [number, string, boolean] = [1, "string", true]; // 여러 타입과 혼합 가능
```

### 6. enum 타입

enum 타입은 열거형이라고도 부르는데 타입스크립트에서 지원하는 특수한 타입이다.

enum 타입은 주로 문자열 상수를 생성하는 데 사용된다. 열거형은 관련이 높은 멤버를 모아 문자열 상수처럼 사용하고자 알 때 유용하게 쓸 수 있다.

각 멤버에 접그하는 방식은 자바스크립트에서 객체의 속성에 접근하는 방식과 동일하다.<br />
또한 역방향으로 접근이 가능하다.

```ts
enum ProgrammingLanguage {
  Typescript,
  Javascript,
  Java,
  Python,
  Kotlin,
}

ProgrammingLanguage.Typescript; // 0

ProgrammingLanguage[2]; // 'Java'
```

열거형을 사용할 때 주의할 점이 있다.<br />
역방향으로 접근이 가능하기 때무에 할당된 값을 넘어서는 범위로 접근하더라도 타입스크립트는 막지 않는다.

이러한 동작을 막기 위해 const enum 으로 열거형을 선언하는 방법이 있다. 이 방식은 역방향 접근을 허용하지 않기 때문에 자바스크립트에서 객체에 접근하는 방식과 유사한 동작을 보장한다.

또는 문자열 상수 방식으로 선언한 열거형은 미리 선언하지 않은 멤버로 접근을 방지한다.

이외에도 열거형의 가장 큰 문제는 열거형이 타입 공간과 값 공간에서 모두 사용되기 때문에 트리쉐이킹이 되지 않아 불필요하게 코드의 크기가 증가할 수 있다는 것이다.

이 문제의 해결을 위해 const enum 또는 as const assertion 을 사용해서 유니온 타입으로 열거형과 동일한 효과를 얻는 방법이 있다.

## 3.2 타입 조합

### 1. 교차 타입(Intersection)

여러 가지 타입을 결합하여 하나의 단일 타입으로 만들 수 있다.

교차 타입은 &을 사용해서 표기한다.

타입 C가 타입 A와 B의 교차 타입 즉, A & B 라면 타입 C는 A와 타입 B의 모든 멤버를 가지고 있는 타입이다.

### 2. 유니언 타입(Union)

교차 타입이 타입 A와 타입 B를 모두 만족하는 경우라면, 유니온 타입은 타입 A 또는 타입 B 중 하나가 될 수 있는 타입을 말한다.

### 3. 인덱스 시그니처(Index Signatures)

특정 타입의 속성 이름은 알 수 없지만 속성값의 타입을 알고 있을 때 사용하는 문법이다.

인터페이스 내부에 [Key: K]: T 이런 형식으로 명시한다.

### 4. 인덱스드 엑세스 타입(Indexed Access Types)

타입의 특정 속성이 가지는 타입을 조회하기 위해 사용된다.

인덱스에 사용되는 타입 또한 그 자체로 타입이기 때문에 유니온 타입, keyof, 타입 별칭 등의 표현을 사용할 수 있다.

### 5. 맵드 타입(Mapped Types)

자바스크립트의 map 은 배열 A를 기반으로 새로운 배열 B를 만들어내는 배열 메서드인데 이와 마찬가지로 맵드 타입은 다른 타입을 기반으로 한 타입을 선언할 때 사용하는 문법이다.

맵드 타입에서 매핑할 때는 readonly 와 ?를 수식어로 적용할 수 있다.

맵드 타입은 이러한 수식어를 더해주는 것뿐만 아니라 제거할 수도 있다. 기존 타입에 존재하던 readonly 나 ? 앞에 -를 붙여주면 해당 수식어를 제거한 타입을 선언할 수 있다.

또 as 키워드를 사용해서 키를 재지정할 수 있다.

### 6. 템플릿 리터럴 타입(Template Literal Types)

자바스크립트의 템플릿 리터럴 문자열을 사용하여 문자열 리터럴 타입을 선언할 수 있는 문법이다.

```ts
type Stage = "init" | "select-image" | "edit-image";

type StageName = `${Stage}-stage`;
// 'init-stage' | 'select-stage' | 'edit-image-stage'
```

### 7. 제네릭(Generic)

제네릭의 사전적 의미는 특징이 없거나 일반적인 것(not specific, general)이다.

타입스크립트의 제네릭도 이와 비슷한 맥락을 가지고 있는데, 일반화된 데이터 타입이라고 할 수 있다.

함수, 타입, 클래스 등에서 내부적으로 사용할 타입을 미리 정해두지 않고 타입 변수를 사용해서 해당 위치를 비워 둔 다음에, 실제로 그 값을 사용할 때 외부에서 타입 변수 자리에 타입을 지정하여 사용하는 방식을 말한다.

이러한 방식은 함수, 타입, 클래스 등 여러 타입에 대해 하나하나 따로 정의하지 않아도 되기 때문에 재사용성이 크게 향상된다.

<T> 와 같이 꺾쇠괄호로 표현하며, 보통 타입 변수명으로 T(Type), E(Element), K(Key), V(Value) 등 한 글자로 된 이름을 많이 사용한다.

함수나 클래스 등 내부에서 제네릭을 사용할 때 어떤 타입이든 될 수 있다는 개념을 알고 있어야 한다. 그렇기 때문에 특정한 타입에서만 존재하는 멤버를 참조하려고 하면 안된다. 이럴 때는 꺾쇠괄호 내부에 제약을 걸어줘서 사용할 수 있다.

```ts
interface TypeWithLength {
  length: number;
}

function exampleFunc<T extends TypeWithLength>(arg: T): number {
  return arg.length;
}
```

## 3.3 제네릭 사용법

### 1. 함수의 제네릭

어떤 함수의 매개변수나 반환 값에 다양한 타입을 넣고 싶을 대 제네릭을 사용할 수 있다.

### 2. 호출 시그니처의 제네릭

호출 시그니처는 타입스크립트의 함수 타입 문법으로 함수의 매개변수와 반환 타입을 미리 선언하는 것을 말한다.

호출 시그니처를 사용할 때 제네릭 타입을 얻디에 위치시키는지에 따라 타입의 범위와 제네릭 타입을 언제 구체 타입으로 한정할지를 결정할 수 있다.

### 3. 제네릭 클래스

제네릭 클래스는 외부에서 입력된 타입을 클래스 내부에 적용할 수 있는 클래스이다.

제네릭 클래스를 사용하면 클래스 전체에 걸쳐 타입 매개변수가 적용된다.

### 4. 제한된 제네릭

타입 매개변수에 대한 제약 조건을 설정하는 기능을 말한다.

예를 들어 string 타입으로 제약하려면 타입 매개변수는 특정 타입을 상속(extends) 해야 한다.

```ts
type ErrorRecord<Key extends string> = Exclude<Key, ErrorCodeType> extends never
  ? Partial<Record<Key, boolean>>
  : never;
```

### 5. 확장된 제네릭

제네릭 타입은 여러 타입을 상속받을 수 있으며 타입 매개변수를 여러 개 둘 수도 있다.

`<Key extends string>`

이렇게 타입을 제약하면 제네릭의 유연성을 잃어버린다.

`<Key extends string | number>`

이렇게 유니온 타입을 상속하면 제네릭이 유연성을 잃지 않으면서 타입을 제약할 수 있다.

### 6. 제네릭 예시

제네릭의 장점은 다양한 타입을 받게 해서 코드를 효율적으로 재사용 할 수 있는 것이다.

제네릭을 궅이 사용하지 않아도 되는 타입에 사용하게 되면 코드 길이만 늘어나고 가독성을 해칠 수 있다.
