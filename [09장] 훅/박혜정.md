# 9장. 훅

## 1. 리액트 훅은 왜 등장했는지

- 기존 클래스형 컴포넌트에서는 라이프 사이클 동안에서만 상태 업데이트 로직을 실행할 수 있었음.
- 프로젝트 규모가 커지면 이러한 사이드이펙트 관련 로직의 관리가 복잡해지고 상태 추적이 어려워지는 문제가 발생
- useEffect 와 같은 훅의 등장으로 사이드 이펙트를 컴포넌트 라이프사이클과 조금 별개로, 관심사별로 분리가 가능해짐
- 또한 비즈니스 로직의 재사용, 코드를 역할에 맞게 분할하여 테스트 하는 것이 용이해짐.

### useEffect 와 useLayoutEffect

- useEffect 는 첫 번째 인자로 EffectCallback 을, 두 번째 인자로 deps arrary 를 받음.
- 이 첫 인자에 async 즉 비동기로 실행되는 함수를 전달할 수 없는 이유는, 이 인자의 반환 타입에 Promise 가 정의되지 않았기 때문.

**Why?!**

- useEffect의 콜백함수는 동기적으로 실행되어야 하기 때문

**Why?!?!**

- 경쟁 상태 Race Condition 을 발생시킬 수 있기 때문
- react 는 상태, props 의 변경에 따라 리렌더링이 이루어짐
- 비동기라는 것은 이 작업이 언제 완료될 지 알 수 없는 작업을 의미하기도 함
- 만약에 useEffect 내부에서 비동기 작업을 수행한다면, 컴포넌트가 리렌더링 될 때 새 비동기 작업이 동시에 실행될 가능성이 있음.
- 경쟁 상태라는 것은 동시에 여러 프로세스, 스레드가 공유 자원에 접근하려는 상태인데, 여기서 실행 순서나 작업 완료 타이밍을 정확히 알 수 없기 때문에 문제가 될 수 있음.
- 따라서 이런 문제를 방지하기 위해 애초에 Promise 를 반환하는 함수는 전달하지 못하도록 해버림.

**아래와 같이 사용해 비동기 작업을 안전하게 처리할 수 있다.**

```ts
useEffect(() => {
  async function runEffect() {
    // ... Effect logic here
  }

  runEffect();

  return () => {
    //  ... Cleanup logic here
}, []);
```

- 비동기 함수 자체를 별도 함수로 분리한 다음 useEffect 내에서 실행하도록 만들어 버리는 것
- 그렇다면 인자로 전달된 이 함수 자체는 그냥 비동기 함수를 실행할 뿐 비동기 함수 자체가 아니기 때문에 에러가 발생하지 않는다.
- 왜냐면 useEffect 자체는 동기적으로 실행되기 때문이다.
- useEffect 는 동기적으로 실행이 되고 종료되기 때문에 비동기로 어디선가 동작할 runEffect 함수의 흐름과 상관없이 동작하므로 useEffect 의 실행 흐름을 방해하지 않는다.
- cleanUp 함수를 전달해 여기에서 다음 리렌더링이 실행되기 전에 현재의 비동기 함수를 클린업 한다던지 뭐 그런식으로 깔끔하게 쓸 수 있음.

- 추가적으로 useEffect 는 렌더링이 모두 완료된 후 실행되지만, useLayoutEffect 는 렌더링이 완료되기 이전에 실행
- 따라서 상태값을 미리 업데이트하여 화면에 보여주고 싶거나, 어떤 로직이 렌더링 이전에 미리 실행되기 원한다면 useLayoutEffect 를 쓰는 것이 좋겠다.

### useMemo 와 useCallback

- 각각 값과 함수를 메모이제이션 하기 위한 훅
- 의존성 배열의 값이 변경될 때에만 값, 함수를 재계산하여 생성하므로 계산에 비용이 많이 드는 경우엔 이를 사용해 성능을 최적화
- 다만 값의 변경을 비교하는 것에도 리소스가 소모되기 때문에 적절하게 사용하는 것이 좋다.
  - 실제로 모든 함수와 값에 useMemo 와 useCallback 을 사용했다가 사용하기 전보다 더 처참한 성능을 본 경험이 있다. ㅋㅋ

### deps. array

- 의존성 배열에 객체를 전달하는 경우, 객체는 참조값만을 비교하는 얕은 비교를 하기 때문에 실제 값이 바뀐 여부와 관계없이 참조값이 바뀌어 버리면 리렌더링 되어버린다.
- 부모에서 받은 인자를 deps 로 전달하는 경우 불필요한 리렌더링이 발생할 수 있다.
- 왜냐면 부모 컴포넌트가 리렌더링 될 때마다 전달되는 props 가 매번 새로운 참조값을 가지기 때문이다.
- 또한 useEffect의 클린업 함수도 마찬가지로 의존성 배열 값이 바뀐 경우에도 매번 실행된다.

### useRef

- ref 란 보통 DOM 에 직접 접근하기 위해 사용되는 객체
- 리렌더링이 일어나도 ref 의 값은 변경되지 않기 때문에, 리렌더링과 상관 없이 유지되어야 하는 값 등은 ref 를 통해 관리하기도 함
- useRef 는 초기화 방식에 따라서 다르게 동작하고, TS 는 이걸 바탕으로 적절하게 ref 타입을 추론한다.

```ts
const countRef = useRef<number>(0); // MutableRefObject<number>
const inputRef = useRef<HTMLInputElement>(null); //  RefObject<HTMLInputElement>
const inputRefMutable = useRef<HTMLInputElement | null>(null); // MutableRefObject<HTMLInputElement | null>
```

- 위와 같이 초기화를 어떻게 하느냐에 따라서 반환 타입이 다르게 나타나는 것을 볼 수 있는데, 각각 어떤 차이가 있는지 살펴보자.

**MutableRefObject**

- current 속성을 읽고 쓸 수 있는 참조.
- 따라서 ref.current 의 값이 변경되는 사이드 이펙트가 발생할 수 있다.
- null이 아닌 값이나 변경이 가능한 참조로 useRef 를 초기화 할 때 발생...

**RefObject**

- current 가 readonly 라서 바꿀 수가 없다.

---

- 그러니까 위 두 차이는, ref 객체의 current 값을 임의로 바꿀 수 있느냐 없느냐의 문제.

```ts
countRef.current = 1;
inputRef.current = "what is wrong whit you?!"; // 읽기 전용 속성이므로 'current'에 할당할 수 없습니다.
```

- 아까 RefObject 타입으로 반환된 ref 값의 current 를 바꾸려고 하니 설명대로 ts 에러가 발생했다.

**왜 이렇게 타입을 구분지어 놓았을까...?**

- current 값의 불변한 참조와 변경 가능한 참조를 구분지으려는 목적이 있는 것 같다.
- 그러니까 왜 구분을 지어놓았을까?
- React 가 관리하는 요소 (RefObject) 그리고 개발자가 직접 관리하는 변경 가능한 요소(MutableRefObject) 로 나누고, 그 의도를 명확히 하고자 한다고 볼 수 있음.
- HtmlInputElement 타입을 제네릭으로 전달한 inputRef 는 ref 로 등록을 하면서 current 에 input DOM 이 할당됨.
- 이렇게 리액트의 규칙에 따라서 동작하고 제어되는 부분이 있기 때문에 이렇게 명시적으로 나눠놓은 것이 아닌가 싶다.

**what is 'current'**

- 아무래도 내 생각에 ref 객체의 프로퍼티로 존재하는 까닭은, 참조값이 아닌 값을 변경해 비교가 발생하지 않게 하기 위함이 아닐까..? 라는 추측.
  - 그렇다. ref 가 객체 형태로 current 라는 속성을 가진 이유가 공식 문서에도 나온다. 그냥 객체라서 언제 이 값이 변경되었는지 알지 못한다고.
- current 라는 네이밍을 생각하면 뭔가 현재 상태 값을 저장하는 느낌이 든다.
- 참고로 useRef 가 이렇게 리렌더링 이후에도 값을 유지할 수 있는 것은 클로저의 원리.
- 클로저란 함수가 생성될 당시의 변수와 환경을 기억해서 그게 다른데에서 호출이 되었더라도 접근할 수 있는 원리.

**자식 컴포넌트에 ref 전달시**

- forwardRef 로 함수형 컴포넌트 자식에게 ref 전달 가능
- 책에 나온 꿀팁으로는 ref 라는 네이밍 대신 inputRef 와 같이 네이밍을 바꿔서 전달...!

### useImperativeHandle

- 부모 컴포넌트가 자식 컴포넌트의 상태 변경, 핸들러를 호출해야 하는 경우 사용할 수 있다.
- 사실 ref 를 과도하게 사용하는 것은 선언형 프로그래밍인 리액트의 방향에 위배되는 것일 수 있음. 그래서 공식문서에도 ref 를 과도하게 사용하지 않도록 강제한다.
- 그래서 상태 끌어올리기 등을 활용해 더 나은 패턴으로 개발할 수 있음.
- 그냥 이런 것도 있다 정도 알아두면 될 듯.
